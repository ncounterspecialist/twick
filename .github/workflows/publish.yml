name: Publish to NPM

permissions:
  contents: read
  id-token: write

on:
  push:
    tags:
      - 'v*'

jobs:
  publish:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          registry-url: 'https://registry.npmjs.org'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8.15.4

      - name: Install dependencies
        run: pnpm install

      - name: Update external @twick packages to latest
        run: |
          # Update external @twick/* packages to their latest versions from npm
          # This ensures we're using the latest external dependencies
          echo "Updating external @twick/* packages to latest versions..."
          
          # External packages that should be updated from npm
          EXTERNAL_PACKAGES=("@twick/core" "@twick/2d" "@twick/cli" "@twick/renderer" "@twick/vite-plugin" "@twick/ui" "@twick/player-react")
          
          # Function to get latest version and update package.json
          update_external_package() {
            local pkg=$1
            local latest_version=$(npm view "$pkg" version 2>/dev/null || echo "")
            
            if [ -z "$latest_version" ]; then
              echo "⚠️  Could not fetch version for $pkg, skipping..."
              return
            fi
            
            echo "  $pkg → ^$latest_version"
            
            # Update in all package.json files
            find packages -name "package.json" -type f | while read file; do
              # Update dependencies
              if jq -e ".dependencies.\"$pkg\"" "$file" > /dev/null 2>&1; then
                current=$(jq -r ".dependencies.\"$pkg\"" "$file")
                prefix="^"
                if [[ "$current" =~ ^~ ]]; then prefix="~"; fi
                jq --arg pkg "$pkg" --arg version "${prefix}${latest_version}" \
                   '.dependencies[$pkg] = $version' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
              fi
              
              # Update devDependencies
              if jq -e ".devDependencies.\"$pkg\"" "$file" > /dev/null 2>&1; then
                current=$(jq -r ".devDependencies.\"$pkg\"" "$file")
                prefix="^"
                if [[ "$current" =~ ^~ ]]; then prefix="~"; fi
                jq --arg pkg "$pkg" --arg version "${prefix}${latest_version}" \
                   '.devDependencies[$pkg] = $version' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
              fi
              
              # Update peerDependencies
              if jq -e ".peerDependencies.\"$pkg\"" "$file" > /dev/null 2>&1; then
                current=$(jq -r ".peerDependencies.\"$pkg\"" "$file")
                prefix="^"
                if [[ "$current" =~ ^~ ]]; then prefix="~"; fi
                jq --arg pkg "$pkg" --arg version "${prefix}${latest_version}" \
                   '.peerDependencies[$pkg] = $version' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
              fi
            done
            
            # Update root package.json pnpm.overrides
            if jq -e ".pnpm.overrides.\"$pkg\"" package.json > /dev/null 2>&1; then
              jq --arg pkg "$pkg" --arg version "^${latest_version}" \
                 '.pnpm.overrides[$pkg] = $version' package.json > package.json.tmp && mv package.json.tmp package.json
            fi
          }
          
          # Update each external package
          for pkg in "${EXTERNAL_PACKAGES[@]}"; do
            update_external_package "$pkg"
          done
          
          echo "✓ External packages updated to latest versions"
          
          # Regenerate lockfile with updated external packages
          echo "Regenerating lockfile with updated external packages..."
          pnpm install --no-frozen-lockfile
          echo "✓ Lockfile regenerated"

      - name: Extract version from tag
        id: version
        run: |
          # Remove 'v' prefix from tag (e.g., v0.14.0 -> 0.14.0)
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Update package versions
        run: |
          # Update all package.json files in packages directory
          find packages -name "package.json" -type f | while read file; do
            echo "Updating version in $file to ${{ steps.version.outputs.version }}"
            # Use jq to update the version field
            jq --arg version "${{ steps.version.outputs.version }}" '.version = $version' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
          done
          
          # Also update the root package.json version
          jq --arg version "${{ steps.version.outputs.version }}" '.version = $version' package.json > package.json.tmp && mv package.json.tmp package.json
          
          # Update root package.json pnpm.overrides if it contains internal @twick packages
          # Only update internal packages, not external ones like @twick/core
          echo "Updating pnpm.overrides in root package.json..."
          INTERNAL_PACKAGES="@twick/media-utils @twick/canvas @twick/timeline @twick/live-player @twick/visualizer @twick/video-editor @twick/studio @twick/render-server @twick/examples @twick/documentation @twick/cloud-export-video @twick/cloud-transcript @twick/cloud-subtitle-video @twick/mcp-agent"
          internal_json=$(echo "$INTERNAL_PACKAGES" | jq -R -s 'split(" ") | map(select(length > 0))')
          jq --arg version "${{ steps.version.outputs.version }}" --argjson internal_packages "$internal_json" '
            def is_internal(pkg_name):
              internal_packages | index(pkg_name) != null;
            
            if .pnpm.overrides then
              .pnpm.overrides |= with_entries(
                if (.key | startswith("@twick/")) and is_internal(.key) then
                  .value = "^" + $version
                else
                  .
                end
              )
            else
              .
            end
          ' package.json > package.json.tmp && mv package.json.tmp package.json

      - name: Update internal dependencies
        run: |
          # List of internal @twick packages (packages in this monorepo)
          # External packages like @twick/core, @twick/2d, @twick/cli should NOT be updated
          INTERNAL_PACKAGES="@twick/media-utils @twick/canvas @twick/timeline @twick/live-player @twick/visualizer @twick/video-editor @twick/studio @twick/render-server @twick/examples @twick/documentation @twick/cloud-export-video @twick/cloud-transcript @twick/cloud-subtitle-video @twick/mcp-agent"
          
          # Helper function to check if a package is internal
          is_internal_package() {
            local pkg_name=$1
            for internal in $INTERNAL_PACKAGES; do
              if [ "$pkg_name" = "$internal" ]; then
                return 0
              fi
            done
            return 1
          }
          
          # Helper function to update only internal @twick/* dependencies to new version
          # This handles both workspace:* and versioned dependencies (e.g., ^0.14.11)
          update_twick_version() {
            local file=$1
            local version=$2
            # Create JSON array of internal packages
            local internal_json=$(echo "$INTERNAL_PACKAGES" | jq -R -s 'split(" ") | map(select(length > 0))')
            jq --arg version "$version" --argjson internal_packages "$internal_json" '
              # Helper function to check if package is internal
              def is_internal(pkg_name):
                internal_packages | index(pkg_name) != null;
              
              # Helper function to update only internal @twick/* dependencies
              # Handles workspace:*, versioned (^0.14.18, ~0.14.18), and exact versions
              def update_twick_deps(deps):
                if deps then
                  deps | with_entries(
                    if (.key | startswith("@twick/")) and is_internal(.key) then
                      # Convert to string for processing
                      (.value | tostring) as $val |
                      if $val == "workspace:*" then
                        # workspace:* → exact version
                        .value = $version
                      elif ($val | startswith("workspace:")) then
                        # workspace:^x.y.z or workspace:~x.y.z → exact version (for publishing)
                        .value = $version
                      elif ($val | startswith("^")) then
                        # ^0.14.18 → ^<new-version> (preserve caret)
                        .value = "^" + $version
                      elif ($val | startswith("~")) then
                        # ~0.14.18 → ~<new-version> (preserve tilde)
                        .value = "~" + $version
                      elif ($val | startswith(">=")) then
                        # >=0.14.18 → >=<new-version>
                        .value = ">=" + $version
                      elif ($val | startswith("<=")) then
                        # <=0.14.18 → <=<new-version>
                        .value = "<=" + $version
                      elif ($val | startswith(">")) then
                        # >0.14.18 → ><new-version>
                        .value = ">" + $version
                      elif ($val | startswith("<")) then
                        # <0.14.18 → <<new-version>
                        .value = "<" + $version
                      elif ($val | test("^[0-9]")) then
                        # 0.14.18 → <new-version> (exact version)
                        .value = $version
                      else
                        # Fallback: use exact version
                        .value = $version
                      end
                    else
                      .
                    end
                  )
                else
                  deps
                end;
              
              # Update all dependency fields
              (if .dependencies then .dependencies = update_twick_deps(.dependencies) else . end) |
              (if .devDependencies then .devDependencies = update_twick_deps(.devDependencies) else . end) |
              (if .peerDependencies then .peerDependencies = update_twick_deps(.peerDependencies) else . end) |
              (if .optionalDependencies then .optionalDependencies = update_twick_deps(.optionalDependencies) else . end)
            ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
          }
          
          # Update internal dependencies in all package.json files
          echo "Updating internal @twick/* dependencies to version ${{ steps.version.outputs.version }}..."
          echo "Internal packages: $INTERNAL_PACKAGES"
          find packages -name "package.json" -type f | while read file; do
            echo "Updating internal dependencies in $file"
            update_twick_version "$file" "${{ steps.version.outputs.version }}"
          done
          
          # Also update root package.json if it has internal @twick dependencies
          if jq -e '.dependencies | keys[] | select(startswith("@twick/"))' package.json > /dev/null 2>&1 || \
             jq -e '.devDependencies | keys[] | select(startswith("@twick/"))' package.json > /dev/null 2>&1 || \
             jq -e '.peerDependencies | keys[] | select(startswith("@twick/"))' package.json > /dev/null 2>&1; then
            echo "Updating internal dependencies in root package.json"
            update_twick_version "package.json" "${{ steps.version.outputs.version }}"
          fi

      - name: Verify version consistency
        run: |
          # Verify all @twick packages have the same version
          echo "Verifying version consistency across all @twick packages..."
          TARGET_VERSION="${{ steps.version.outputs.version }}"
          ERRORS=0
          
          # Check package versions
          find packages -name "package.json" -type f | while read file; do
            PACKAGE_NAME=$(jq -r '.name' "$file")
            if [[ "$PACKAGE_NAME" == @twick/* ]]; then
              PACKAGE_VERSION=$(jq -r '.version' "$file")
              if [ "$PACKAGE_VERSION" != "$TARGET_VERSION" ]; then
                echo "❌ ERROR: $PACKAGE_NAME has version $PACKAGE_VERSION, expected $TARGET_VERSION"
                ERRORS=1
              else
                echo "✓ $PACKAGE_NAME: $PACKAGE_VERSION"
              fi
            fi
          done
          
          # Check root package.json version
          ROOT_VERSION=$(jq -r '.version' package.json)
          if [ "$ROOT_VERSION" != "$TARGET_VERSION" ]; then
            echo "❌ ERROR: Root package.json has version $ROOT_VERSION, expected $TARGET_VERSION"
            ERRORS=1
          else
            echo "✓ Root package.json: $ROOT_VERSION"
          fi
          
          if [ $ERRORS -eq 1 ]; then
            echo "❌ Version consistency check failed!"
            exit 1
          fi
          
          echo "✅ All @twick packages have version $TARGET_VERSION"

      - name: Regenerate lockfile
        run: |
          # Regenerate lockfile after updating package versions and dependencies
          echo "Regenerating pnpm-lock.yaml with updated versions..."
          pnpm install --no-frozen-lockfile
          echo "✓ Lockfile regenerated"

      - name: Clean workspace dependencies
        run: |
          # Clean workspace: prefixes from dependencies for publishing
          echo "Cleaning workspace dependencies for publishing..."
          
          # Check if the script exists
          if [ ! -f "scripts/action-for-publish.js" ]; then
            echo "Error: scripts/action-for-publish.js not found"
            exit 1
          fi
          
          # Run the workspace dependency cleanup script
          if ! node scripts/action-for-publish.js; then
            echo "Error: Failed to clean workspace dependencies"
            exit 1
          fi

      - name: Regenerate lockfile after cleaning
        run: |
          # Regenerate lockfile after cleaning workspace: prefixes
          # This ensures lockfile matches the cleaned dependencies for publishing
          # External @twick/* packages (like @twick/core, @twick/2d, @twick/cli) will be installed from npm
          echo "Regenerating pnpm-lock.yaml after cleaning workspace dependencies..."
          pnpm install --no-frozen-lockfile
          echo "✓ Lockfile regenerated with cleaned dependencies"

      - name: Build all packages
        run: pnpm build

      - name: Verify builds
        run: |
          # Check that all packages have dist folders (excluding documentation)
          # This handles both top-level and nested packages (e.g., cloud-functions/*, agents/*)
          find packages -name "package.json" -type f | while read pkg_file; do
            package_dir=$(dirname "$pkg_file")
            package_name=$(jq -r '.name' "$pkg_file")
            package_dirname=$(basename "$package_dir")
            
            # Skip documentation package
            if [ "$package_dirname" = "documentation" ]; then
              echo "⏭️  Skipping documentation package"
              continue
            fi
            
            # Check if package has a build script - if not, dist might not be required
            if jq -e '.scripts.build' "$pkg_file" > /dev/null 2>&1; then
              if [ ! -d "$package_dir/dist" ]; then
                echo "❌ ERROR: $package_name is missing dist folder (expected at $package_dir/dist)"
                exit 1
              fi
              echo "✓ $package_name built successfully"
            else
              echo "⏭️  Skipping $package_name (no build script)"
            fi
          done

      - name: Security validation
        run: |
          # Check for potentially dangerous scripts in package.json files (excluding documentation)
          # This handles both top-level and nested packages
          echo "Validating package security..."
          
          find packages -name "package.json" -type f | while read pkg_file; do
            package_dir=$(dirname "$pkg_file")
            package_name=$(jq -r '.name' "$pkg_file")
            package_dirname=$(basename "$package_dir")
            
            # Skip documentation package
            if [ "$package_dirname" = "documentation" ]; then
              echo "⏭️  Skipping documentation package security check"
              continue
            fi
            
            # Check for postinstall scripts (security risk)
            if jq -e '.scripts.postinstall' "$pkg_file" > /dev/null 2>&1; then
              echo "SECURITY WARNING: $package_name has a postinstall script"
              echo "This is a security risk and will be ignored during publishing"
            fi
            
            # Check for other potentially dangerous scripts
            DANGEROUS_SCRIPTS=("preinstall" "install" "postinstall" "preuninstall" "uninstall" "postuninstall" "prepublish" "prepublishOnly" "prepack" "postpack")
            
            for script in "${DANGEROUS_SCRIPTS[@]}"; do
              if jq -e ".scripts.$script" "$pkg_file" > /dev/null 2>&1; then
                echo "⚠️  WARNING: $package_name has a $script script"
              fi
            done
            
            echo "✓ $package_name security check completed"
          done

      - name: Determine publish order
        id: publish-order
        run: |
          # Use our custom script to determine dependency-aware publish order
          echo "Determining publish order based on dependencies..."
          
          # Check if the script exists
          if [ ! -f "scripts/get-publish-order.js" ]; then
            echo "Error: scripts/get-publish-order.js not found"
            exit 1
          fi
          
          # Run the dependency analysis script
          SCRIPT_OUTPUT=$(node scripts/get-publish-order.js 2>&1)
          if [ $? -ne 0 ]; then
            echo "Error running get-publish-order.js:"
            echo "$SCRIPT_OUTPUT"
            echo "Using fallback order"
            PUBLISH_ORDER="media-utils canvas timeline live-player visualizer video-editor render-server"
          else
            PUBLISH_ORDER=$(echo "$SCRIPT_OUTPUT" | grep "Publish order string:" | cut -d: -f2 | xargs)
            
            # Fallback order if script fails to output expected format
            if [ -z "$PUBLISH_ORDER" ]; then
              echo "Warning: Could not determine dependency order, using fallback order"
              PUBLISH_ORDER="media-utils canvas timeline live-player visualizer video-editor render-server"
            fi
          fi
          
          # Ensure cloud-functions/export-video is included at the end (nested package)
          if [[ ! " $PUBLISH_ORDER " =~ " cloud-functions/export-video " ]]; then
            PUBLISH_ORDER="$PUBLISH_ORDER cloud-functions/export-video"
          fi
          
          echo "Publish order: $PUBLISH_ORDER"
          echo "publish-order=$PUBLISH_ORDER" >> $GITHUB_OUTPUT

      - name: Publish packages to NPM
        run: |
          # Publish packages in dependency order with security flags
          for package in ${{ steps.publish-order.outputs.publish-order }}; do
            if [ -d "packages/$package" ] && [ -f "packages/$package/package.json" ]; then
              package_name=$(jq -r '.name' "packages/$package/package.json")
              echo "Publishing $package_name (from $package)..."
              cd "packages/$package"

              if jq -e '.scripts.build' package.json > /dev/null 2>&1; then
                echo "Building $package_name to ensure dist artifacts are present..."
                pnpm run build
              else
                echo "No build script found for $package_name, skipping build step."
              fi
              
              # Use --ignore-scripts to prevent malicious postinstall scripts
              # Use --access public to ensure public access
              # Use --dry-run first to validate
              if [ "$package_name" = "@twick/cloud-export-video" ]; then
                echo "Running dry-run for $package_name with aws tag..."
                npm publish --access public --ignore-scripts --tag aws --dry-run
                echo "Publishing $package_name with aws tag..."
                npm publish --access public --ignore-scripts --tag aws
              else
                echo "Running dry-run for $package_name..."
                npm publish --access public --ignore-scripts --dry-run
                echo "Publishing $package_name..."
                npm publish --access public --ignore-scripts
              fi

              cd - >/dev/null 2>&1
              echo "✓ Successfully published $package_name"
            else
              echo "Warning: Package $package not found or missing package.json"
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Restore workspace dependencies
        if: always()
        run: |
          # Restore workspace: prefixes in dependencies after publishing
          echo "Restoring workspace dependencies..."
          
          # Check if the script exists
          if [ ! -f "scripts/action-for-publish.js" ]; then
            echo "Warning: scripts/action-for-publish.js not found, skipping restore"
            exit 0
          fi
          
          # Run the workspace dependency restore script
          if ! node scripts/action-for-publish.js --restore; then
            echo "Warning: Failed to restore workspace dependencies"
            # Don't fail the workflow on restore failure
          fi 